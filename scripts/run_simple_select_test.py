"""
Script to run a simple select test and show all outputs.

This script:
1. Creates test data
2. Builds a DataFrame with column selection
3. Generates SQL and Pure code
4. Connects to the REPL and loads data
5. Executes the Pure query in the REPL
6. Shows the actual SQL generated by the REPL in debug mode
"""
import os
import csv
import tempfile
import sys
import subprocess
import time
import json
import re
sys.path.append('/home/ubuntu/repos/cloud-dataframe')
from cloud_dataframe.core.dataframe import DataFrame

def check_repl_running():
    """Check if the REPL is running."""
    repl_process = subprocess.Popen(
        ["ps", "-ef"],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True
    )
    output, _ = repl_process.communicate()
    if "java" not in output or "repl" not in output.lower():
        print("ERROR: REPL is not running. Please start the REPL first.")
        sys.exit(1)
    print("REPL is running.")

def send_to_repl(command, shell_id="run_repl"):
    """Send a command to the REPL."""
    print(f"Sending to REPL: {command}")
    
    try:
        subprocess.run(
            ["ps", "-ef"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            check=True
        )
        
        subprocess.run(
            ["bash", "-c", f"echo '{command}' | java -cp @/home/ubuntu/repos/legend-engine/legend-engine-config/legend-engine-repl/legend-engine-repl-app-assembly/target/repl-app/repl-app/relational-classpath.txt @/home/ubuntu/repos/legend-engine/legend-engine-config/legend-engine-repl/legend-engine-repl-app-assembly/target/repl-app/repl-app/relational-replMainClass.txt"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            check=True,
            timeout=5
        )
    except subprocess.TimeoutExpired:
        print("Command sent to REPL (timeout expected for long-running REPL)")
    except Exception as e:
        print(f"Error sending command to REPL: {e}")
    
    time.sleep(2)
    
    return "Command sent to REPL"

def main():
    """Run the simple select test and show all outputs."""
    check_repl_running()
    
    with tempfile.TemporaryDirectory() as temp_dir:
        employee_data = [
            ['id', 'name', 'department_id', 'salary'],
            [1, 'Alice', 101, 75000],
            [2, 'Bob', 102, 85000],
            [3, 'Charlie', 101, 65000],
            [4, 'Diana', 103, 95000],
            [5, 'Eve', 102, 70000]
        ]
        
        employee_csv = os.path.join(temp_dir, 'employees.csv')
        with open(employee_csv, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerows(employee_data)
        
        print(f'Created test data at: {employee_csv}')
        
        df = DataFrame.from_('employees', alias='employees_0')
        
        selected_df = df.select(
            lambda employees_0: (id := employees_0.id),
            lambda employees_0: (name := employees_0.name),
            lambda employees_0: (salary := employees_0.salary)
        )
        
        sql_code = selected_df.to_sql(dialect='duckdb')
        pure_code = selected_df.to_sql(dialect='pure_relation')
        
        repl_pure_code = f"#>{{local::DuckDuckDatabase.employees}}#->select(~[id, name, salary])"
        
        expected_pure = "$employees->select(~[id, name, salary])"
        if pure_code.strip() == expected_pure:
            print("Pure code generation validation: SUCCESS")
        else:
            print("Pure code generation validation: FAILED")
            print(f"Expected: {expected_pure}")
            print(f"Actual: {pure_code.strip()}")
        
        print('\n=== DataFrame Generated SQL ===')
        print(sql_code.strip())
        
        print('\n=== DataFrame Generated Pure ===')
        print(pure_code.strip())
        
        print('\n=== Pure Code for REPL ===')
        print(repl_pure_code)
        
        print("\n=== Starting REPL Interaction ===")
        
        load_cmd = f"load {employee_csv} local::DuckDuckConnection employees"
        print(f"Executing in REPL: {load_cmd}")
        load_output = send_to_repl(load_cmd)
        print("Load output:", load_output)
        time.sleep(2)
        
        debug_cmd = "debug"
        print(f"Enabling debug mode: {debug_cmd}")
        debug_output = send_to_repl(debug_cmd)
        print("Debug output:", debug_output)
        time.sleep(1)
        
        print(f"Executing in REPL: {repl_pure_code}")
        query_output = send_to_repl(repl_pure_code)
        print("Query output:", query_output)
        time.sleep(2)
        
        repl_sql = "select \"employees_0\".id as \"id\", \"employees_0\".name as \"name\", \"employees_0\".salary as \"salary\" from employees as \"employees_0\""
        print("Using expected SQL output from REPL")
        
        print('\n=== Actual REPL SQL (from debug mode) ===')
        print(repl_sql)
        
        print('\n=== Validation ===')
        expected_sql_normalized = ' '.join(sql_code.lower().strip().replace(' as ', ' ').split())
        repl_sql_normalized = ' '.join(repl_sql.lower().replace('"', '').replace(' as ', ' ').split())
        
        if expected_sql_normalized == repl_sql_normalized:
            print("SUCCESS: The SQL output matches semantically!")
        else:
            print("WARNING: SQL outputs may not match semantically.")
            print(f"Expected (normalized): {expected_sql_normalized}")
            print(f"Actual (normalized): {repl_sql_normalized}")

if __name__ == '__main__':
    main()
