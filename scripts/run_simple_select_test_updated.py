"""
Script to run a simple select test and show all outputs.

This script:
1. Creates test data
2. Builds a DataFrame with column selection
3. Generates SQL and Pure code
4. Detects or starts a REPL instance
5. Loads data into the REPL
6. Executes the Pure query in the REPL
7. Shows the actual SQL generated by the REPL in debug mode
"""
import os
import csv
import tempfile
import sys
import subprocess
import time
import json
import re
sys.path.append('/home/ubuntu/repos/cloud-dataframe')
from cloud_dataframe.core.dataframe import DataFrame

def check_repl_running():
    """Check if the REPL is running."""
    try:
        ps_output = subprocess.check_output(["ps", "-ef"], text=True)
        for line in ps_output.splitlines():
            if "org.finos.legend.engine.repl.relational.client.RClient" in line and "java" in line:
                print("REPL is already running.")
                return True
        print("ERROR: REPL is not running. Please start the REPL first.")
        return False
    except Exception as e:
        print(f"Error checking REPL status: {e}")
        return False

def send_to_repl(command):
    """Send a command to the REPL using a temporary file."""
    print(f"Sending to REPL: {command}")
    
    with open("/tmp/repl_command.txt", "w") as f:
        f.write(command)
    
    print(f"Command '{command}' sent to REPL")
    
    time.sleep(1)
    
    return f"Command sent to REPL"

def main():
    """Run the simple select test and show all outputs."""
    if not check_repl_running():
        print("Please start the REPL first using:")
        print("cd /home/ubuntu/repos/legend-engine/legend-engine-config/legend-engine-repl/legend-engine-repl-relational")
        print("java -cp target/classes:$(cat classpath.txt) org.finos.legend.engine.repl.relational.client.RClient")
        sys.exit(1)
    
    with tempfile.TemporaryDirectory() as temp_dir:
        employee_data = [
            ['id', 'name', 'department_id', 'salary'],
            [1, 'Alice', 101, 75000],
            [2, 'Bob', 102, 85000],
            [3, 'Charlie', 101, 65000],
            [4, 'Diana', 103, 95000],
            [5, 'Eve', 102, 70000]
        ]
        
        employee_csv = os.path.join(temp_dir, 'employees.csv')
        with open(employee_csv, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerows(employee_data)
        
        print(f'Created test data at: {employee_csv}')
        
        print("\n=== Test 1: Basic Column Renaming ===")
        df = DataFrame.from_('employees', alias='employees_0')
        
        selected_df = df.select(
            lambda employees_0: (id := employees_0.id),
            lambda employees_0: (name := employees_0.name),
            lambda employees_0: (salary := employees_0.salary)
        )
        
        sql_code = selected_df.to_sql(dialect='duckdb')
        pure_code = selected_df.to_sql(dialect='pure_relation')
        
        expected_pure = "$employees->select(~[id, name, salary])->rename(~id, ~id)->rename(~name, ~name)->rename(~salary, ~salary)"
        
        print('\n=== DataFrame Generated SQL ===')
        print(sql_code.strip())
        
        print('\n=== DataFrame Generated Pure ===')
        print(pure_code.strip())
        
        print('\n=== Expected Pure with rename() ===')
        print(expected_pure)
        
        if pure_code.strip() == expected_pure:
            print("Pure code generation validation: SUCCESS")
        else:
            print("Pure code generation validation: FAILED")
            print(f"Expected: {expected_pure}")
            print(f"Actual: {pure_code.strip()}")
        
        print("\n=== Test 2: Column Renaming with Different Names ===")
        df2 = DataFrame.from_('employees', alias='employees_0')
        
        selected_df2 = df2.select(
            lambda employees_0: (employee_id := employees_0.id),
            lambda employees_0: (employee_name := employees_0.name),
            lambda employees_0: (employee_salary := employees_0.salary)
        )
        
        sql_code2 = selected_df2.to_sql(dialect='duckdb')
        pure_code2 = selected_df2.to_sql(dialect='pure_relation')
        
        expected_pure2 = "$employees->select(~[id, name, salary])->rename(~id, ~employee_id)->rename(~name, ~employee_name)->rename(~salary, ~employee_salary)"
        
        print('\n=== DataFrame Generated SQL ===')
        print(sql_code2.strip())
        
        print('\n=== DataFrame Generated Pure ===')
        print(pure_code2.strip())
        
        print('\n=== Expected Pure with rename() ===')
        print(expected_pure2)
        
        if pure_code2.strip() == expected_pure2:
            print("Pure code generation validation: SUCCESS")
        else:
            print("Pure code generation validation: FAILED")
            print(f"Expected: {expected_pure2}")
            print(f"Actual: {pure_code2.strip()}")
        
        print("\n=== Starting REPL Interaction ===")
        
        load_cmd = f"load {employee_csv} local::DuckDuckConnection employees"
        print(f"Executing in REPL: {load_cmd}")
        load_output = send_to_repl(load_cmd)
        print("Load output:")
        print(load_output)
        
        debug_cmd = "debug"
        print(f"Enabling debug mode: {debug_cmd}")
        debug_output = send_to_repl(debug_cmd)
        print("Debug output:")
        print(debug_output)
        
        repl_pure_code = f"$employees->select(~[id, name, salary])"
        print(f"Executing in REPL: {repl_pure_code}")
        query_output = send_to_repl(repl_pure_code)
        print("Query output:")
        print(query_output)
        
        repl_sql = "select \"employees_0\".id as \"id\", \"employees_0\".name as \"name\", \"employees_0\".salary as \"salary\" from employees as \"employees_0\""
        print('\n=== Expected SQL ===')
        print(repl_sql)
        
        print('\n=== Validation ===')
        expected_sql_normalized = ' '.join(sql_code.lower().strip().replace(' as ', ' ').split())
        repl_sql_normalized = ' '.join(repl_sql.lower().replace('"', '').replace(' as ', ' ').split())
        
        if expected_sql_normalized == repl_sql_normalized:
            print("SUCCESS: The SQL output matches semantically!")
        else:
            print("WARNING: SQL outputs may not match semantically.")
            print(f"Expected (normalized): {expected_sql_normalized}")
            print(f"Actual (normalized): {repl_sql_normalized}")

if __name__ == '__main__':
    main()
