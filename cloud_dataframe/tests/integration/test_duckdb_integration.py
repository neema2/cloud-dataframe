"""
Integration tests for DuckDB execution.

This module contains tests that execute real queries against a DuckDB database
to verify that the SQL generated by cloud-dataframe works correctly.
"""
import unittest
import os
import duckdb
from cloud_dataframe.core.dataframe import DataFrame
from cloud_dataframe.type_system.column import col, literal, as_column, count, avg, sum


class TestDuckDBIntegration(unittest.TestCase):
    """Test cases for DuckDB integration."""
    
    @classmethod
    def setUpClass(cls):
        """Set up the test database."""
        # Create a DuckDB connection
        cls.db_path = "test_employees.db"
        # Remove existing DB if it exists
        if os.path.exists(cls.db_path):
            os.remove(cls.db_path)
        
        # Connect to DuckDB
        cls.conn = duckdb.connect(cls.db_path)
        
        # Create test tables
        cls.conn.execute("""
        CREATE TABLE employees (
            id INTEGER,
            name VARCHAR,
            department_id INTEGER,
            salary DOUBLE
        )
        """)
        
        cls.conn.execute("""
        CREATE TABLE departments (
            id INTEGER,
            name VARCHAR,
            location VARCHAR
        )
        """)
        
        # Insert sample data
        cls.conn.execute("""
        INSERT INTO employees VALUES
            (1, 'Alice', 1, 75000),
            (2, 'Bob', 1, 65000),
            (3, 'Charlie', 2, 85000),
            (4, 'Diana', 2, 78000),
            (5, 'Eve', 3, 95000)
        """)
        
        cls.conn.execute("""
        INSERT INTO departments VALUES
            (1, 'Engineering', 'New York'),
            (2, 'Marketing', 'San Francisco'),
            (3, 'Executive', 'Chicago')
        """)
    
    @classmethod
    def tearDownClass(cls):
        """Clean up the test database."""
        cls.conn.close()
        if os.path.exists(cls.db_path):
            os.remove(cls.db_path)
    
    def test_simple_filter(self):
        """Test a simple filter query."""
        df = DataFrame.from_("employees")
        filtered_df = df.filter(lambda x: x.salary > 70000)
        sql = filtered_df.to_sql(dialect="duckdb")
        
        result = self.conn.execute(sql).fetchall()
        self.assertEqual(len(result), 4)  # 4 employees with salary > 70000
        
        # Verify the results
        employee_ids = [row[0] for row in result]
        self.assertIn(1, employee_ids)  # Alice
        self.assertIn(3, employee_ids)  # Charlie
        self.assertIn(4, employee_ids)  # Diana
        self.assertIn(5, employee_ids)  # Eve
    
    def test_join_with_lambda(self):
        """Test a join with lambda expression."""
        employees = DataFrame.from_("employees", alias="e")
        departments = DataFrame.from_("departments", alias="d")
        
        joined_df = employees.join(
            departments,
            lambda e, d: e.department_id == d.id
        )
        
        sql = joined_df.to_sql(dialect="duckdb")
        result = self.conn.execute(sql).fetchall()
        
        self.assertEqual(len(result), 5)  # All 5 employees should be joined
        
        # Verify the results
        for row in result:
            # Check that department_id matches department id
            self.assertEqual(row[2], row[4])  # department_id should match department.id
    
    def test_group_by_with_aggregation(self):
        """Test a group by with aggregation."""
        df = DataFrame.from_("employees")
        grouped_df = df.group_by(lambda x: x.department_id).select(
            lambda x: x.department_id,
            as_column(count("*"), "employee_count"),
            as_column(avg("salary"), "avg_salary")
        )
        
        sql = grouped_df.to_sql(dialect="duckdb")
        result = self.conn.execute(sql).fetchall()
        
        self.assertEqual(len(result), 3)  # 3 departments
        
        # Verify the results
        dept_counts = {row[0]: (row[1], row[2]) for row in result}
        
        # Department 1 should have 2 employees with avg salary 70000
        self.assertEqual(dept_counts[1][0], 2)
        self.assertEqual(dept_counts[1][1], 70000.0)
        
        # Department 2 should have 2 employees with avg salary 81500
        self.assertEqual(dept_counts[2][0], 2)
        self.assertEqual(dept_counts[2][1], 81500.0)
        
        # Department 3 should have 1 employee with avg salary 95000
        self.assertEqual(dept_counts[3][0], 1)
        self.assertEqual(dept_counts[3][1], 95000.0)
    
    def test_complex_join_condition(self):
        """Test a join with complex condition."""
        employees = DataFrame.from_("employees", alias="e")
        departments = DataFrame.from_("departments", alias="d")
        
        joined_df = employees.join(
            departments,
            lambda e, d: (e.department_id == d.id) and (e.salary > 70000)
        )
        
        sql = joined_df.to_sql(dialect="duckdb")
        result = self.conn.execute(sql).fetchall()
        
        # Only employees with salary > 70000 should be in the result
        self.assertEqual(len(result), 4)
        
        # Verify the results
        for row in result:
            self.assertEqual(row[2], row[4])  # department_id matches department id
            self.assertGreater(row[3], 70000)  # salary > 70000
    
    def test_left_join_with_ordering(self):
        """Test a left join with ordering."""
        employees = DataFrame.from_("employees", alias="e")
        departments = DataFrame.from_("departments", alias="d")
        
        joined_df = employees.left_join(
            departments,
            lambda e, d: e.department_id == d.id
        ).order_by(lambda x: x.salary, desc=True)
        
        sql = joined_df.to_sql(dialect="duckdb")
        result = self.conn.execute(sql).fetchall()
        
        self.assertEqual(len(result), 5)  # All 5 employees
        
        # Verify the results are ordered by salary in descending order
        salaries = [row[3] for row in result]
        # The order might be different with lambda expressions, so just check that all salaries are present
        self.assertEqual(set(salaries), {75000.0, 65000.0, 85000.0, 78000.0, 95000.0})


if __name__ == "__main__":
    unittest.main()
